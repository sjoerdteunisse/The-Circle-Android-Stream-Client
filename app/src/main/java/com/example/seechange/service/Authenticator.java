package com.example.seechange.service;
import android.content.Context;
import android.util.Base64;
import android.util.Log;
import java.security.GeneralSecurityException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.Signature;

public class Authenticator {
    private String privateKeyString;
    private String publicKeyString;
    private String phoneNumber;

    public Authenticator(Context appContext) {
        // Retrieve the phone number and keys
        phoneNumber = SharedPreferencesHandler.getStoredPhoneNumber(appContext);
        privateKeyString = SharedPreferencesHandler.getStoredPrivateKey(appContext);
        publicKeyString = SharedPreferencesHandler.getStoredPublicKey(appContext);
    }

    public String initSignature() {
        try {
            // Create the private key object from a "privateKey" string.
            PrivateKey privateKey = KeyHandler.getPrivateKey(privateKeyString);
            // Create the public key object from a "publicKey" string.
            PublicKey publicKey = KeyHandler.getPublicKey(publicKeyString);
            // Get the bytes of the phoneNumber to generate a digital signature based upon the bytes.
            byte[] phoneBytes = phoneNumber.getBytes();
            // Init SHA256 with RSA keys
            Signature sig = Signature.getInstance("SHA256withRSA");
            // Sign the digital signature...
            sig.initSign(privateKey);
            // with the private key...
            sig.update(phoneBytes);
            // and based on the bytes of the phone number

            // Check if the digital signature was successfully generated by verifying it with the public key.
            byte[] digitalSignature = sig.sign();
            sig.initVerify(publicKey);
            sig.update(phoneBytes);
            boolean validSignature = sig.verify(digitalSignature);
            if (validSignature) {
                Log.d("Signature", "Valid Signature");
                return Base64.encodeToString(digitalSignature, Base64.DEFAULT);
            } else {
                Log.d("Signature:", "Invalid Signature");
            }
        } catch (GeneralSecurityException e) {
            e.printStackTrace();
        }
        return null;
    }

    public String registerDigiSig(String userInfo) throws GeneralSecurityException {
        // Create the private key object from a "privateKey" string.
        PrivateKey privateKey = KeyHandler.getPrivateKey(privateKeyString);
        // Create the public key object from a "publicKey" string.
        PublicKey publicKey = KeyHandler.getPublicKey(publicKeyString);
        // Get the bytes of the user info to generate a digital signature based upon the bytes.
        byte[] userBytes = userInfo.getBytes();
        Signature sig = Signature.getInstance("SHA256withRSA");
        // Sign the digital signature...
        sig.initSign(privateKey);
        // with the private key...
        sig.update(userBytes);
        // and based on the bytes of the user info
        // Check if the digital signature was successfully generated by verifying it with the public key.
        byte[] digitalSignature = sig.sign();
        sig.initVerify(publicKey);
        sig.update(userBytes);
        boolean validSignature = sig.verify(digitalSignature);
        if (validSignature) {
            Log.d("Signature", "Valid Signature");
            return Base64.encodeToString(digitalSignature, Base64.DEFAULT);
        } else {
            Log.d("Signature:", "Invalid Signature");
        }
        return null;
    }
}
